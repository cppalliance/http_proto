//
// Copyright (c) 2025 Vinnie Falco (vinnie.falco@gmail.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// Official repository: https://github.com/cppalliance/buffers
//

= HTTP Primer

HTTP is a stream-oriented protocol between two connected programs: one acting
as the client, the other as the server. While the connection is open, the client
sends an HTTP request, which the server reads and answers with an HTTP response.
These _messages_ are paired in order; each request has exactly one
corresponding response. This exchange of structured messages continues until
either peer closes the connection, whether normally or due to an error.

HTTP messages consist of three parts: the start line, the headers, and the
message body. The start line differs between requests and responses, while
the headers and body share the same structure. Headers are made up of zero
or more fields, each expressed as a nameâ€“value pair. Both the start line and
the header fields use a line-oriented text format, with each line terminated
by a CRLF sequence (carriage return followed by line feed, i.e. bytes
`0x0D 0x0A`). The message body is a sequence of bytes of defined length,
with content determined by the semantics of the start line and headers.

This diagram shows an actual HTTP request and HTTP response

[cols="1a,1a"]
|===
|HTTP Request|HTTP Response

|
[source]
----
GET /index.html HTTP/1.1\r\n
User-Agent: Boost\r\n
\r\n
----
|
[source]
----
HTTP/1.1 200 OK\r\n
Server: Boost.Http.Proto\r\n
Content-Length: 13\r\n
\r\n
Hello, world!
----

|===

More formally, the ABNF for HTTP messages is defined as follows:

[cols="1a,4a"]
|===
|Name|ABNF

|message
|[literal]
HTTP-message   = request-line / status-line
                 *( header-field CRLF )
                 CRLF
                 [ message-body ]

|request-line
|[literal]
request-line   = method SP request-target SP HTTP-version CRLF

|status-line
|[literal]
status-line    = HTTP-version SP status-code SP reason-phrase CRLF

|===


Most HTTP header field values are domain-specific or application-defined, while
certain fields commonly recur. The library understands these fields and takes
appropriate action to ensure RFC compliance:

[cols="1a,4a"]
|===
|Field|Description

a|
https://tools.ietf.org/html/rfc7230#section-6.1[*Connection*] +
https://tools.ietf.org/html/rfc7230#appendix-A.1.2[*Proxy-Connection*]

|This field lets the sender specify control options for the current connection.
Typical values include close, keep-alive, and upgrade.

|https://tools.ietf.org/html/rfc7230#section-3.3.2[*Content-Length*]
|When present, this field tells the recipient the exact size of the message
body, measured in bytes, that follows the header.

|https://tools.ietf.org/html/rfc7230#section-3.3.1[*Transfer-Encoding*]
|This optional field specifies the sequence of transfer codings that have been,
or will be, applied to the content payload to produce the message body.

The library supports the
chunked,
gzip,
deflate, and
brotli
encoding schemes,
in any valid combination. Encodings can be automatically applied or removed
as needed by the caller.

|https://tools.ietf.org/html/rfc7230#section-6.7[*Upgrade*]
|The Upgrade header field provides a mechanism to transition from HTTP/1.1 to
another protocol on the same connection. For example, it is the mechanism used
by WebSocket's initial HTTP handshake to establish a WebSocket connection.

|===

